<!DOCTYPE html>
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<style>
canvas {
    border: 1px solid #d3d3d3;
    background-color: #f1f1f1;
}
</style>
</head>
<body onload="startGame()">
<script>

function startGame() {
    myGameArea.start();
    canvassGrid = grid;
    canvassGrid.initializeGrid(7, 15, myGameArea.canvas);
    canvassGrid.getCells();
    canvassGrid.createBorders(borderwidth=3);
    myGameArea.canvas.addEventListener("click", (event) => { console.log(event); canvassGrid.getCellSurroundingXandYcoordinate(event.x, event.y) } )
}

var myGameArea = {
    canvas : document.createElement("canvas"),
    start : function() {
        this.canvas.width = 480;
        this.canvas.height = 270;
        this.context = this.canvas.getContext("2d");
        document.body.insertBefore(this.canvas, document.body.childNodes[0]);
    }
}

getInfoOnCell = function(rowNumber, columnNumber, rowSize, columnSize) {
        cellData = {
            topBorder : rowNumber * rowSize,
            bottomBorder : (rowNumber + 1) * rowSize,
            leftBorder : columnNumber * columnSize,
            rightBorder : (columnNumber + 1) * columnSize
        }

        // console.log(cellData)

        return cellData
    }


var grid = {
    numberOfRows : 5,
    numberOfColumns : 5,
    canvas : null,
    gridArray : [],
    initializeGrid : function(number_of_rows, number_of_columns, inputtedCanvas) {
        self.numberOfRows = number_of_rows;
        self.numberOfColumns = number_of_columns;
        self.canvas = inputtedCanvas;
        console.log("Rows: ", self.numberOfRows, "\nColumns: ", self.numberOfColumns, "\nCanvas: ", self.canvas)
    },
    getInfoOnCell : function(rowNumber, columnNumber, rowSize, columnSize) {
        cellData = {
            topBorder : rowNumber * rowSize,
            bottomBorder : (rowNumber + 1) * rowSize,
            leftBorder : columnNumber * columnSize,
            rightBorder : (columnNumber + 1) * columnSize
        }

        // console.log(cellData)

        return cellData
    },
    getCells : function() {
        rowSize = self.canvas.height/self.numberOfRows;
        columnSize = self.canvas.width/self.numberOfColumns;
        self.gridArray = []
        for (let i=0; i<self.numberOfRows; i++) {
            gridArray.push([]);
            for(let j=0; j<self.numberOfColumns; j++) {
                gridArray[i].push(getInfoOnCell(i, j, rowSize, columnSize)  );

            }
        }
    },
    createBorders : function(borderwidth=5, fillstyle="black") {
        self.canvas.fillStyle = fillstyle;
        canvas = self.canvas
        context = self.canvas.getContext("2d")
        gridArray = self.gridArray

        for (let row=0;row<gridArray.length;row++) {
            context.fillRect(0, gridArray[row][0]['topBorder'] - borderwidth/2, canvas.width, borderwidth);
            context.fillRect(0, gridArray[row][0]['bottomBorder'] - borderwidth/2, canvas.width, borderwidth);

        }
        for (let column=0;column<self.gridArray[0].length;column++) {
            context.fillRect(gridArray[0][column]['leftBorder'] - borderwidth/2, 0, borderwidth, canvas.height);
            context.fillRect(gridArray[0][column]['rightBorder'] - borderwidth/2, 0, borderwidth, canvas.height);

        }

    },

    getCellSurroundingXandYcoordinate : function(inputX, inputY) {
        gridArray = self.gridArray;

        rowOfSelectedCell = 0;
        for (let row=0; row<gridArray.length; row++) {
            topBorder = gridArray[row][0]['topBorder'];
            bottomBorder = gridArray[row][0]['bottomBorder'];
            if ((inputY > topBorder) && (inputY < bottomBorder)) {
                rowOfSelectedCell = row;
            }

        }

        columnOfSelectedCell = 0;
        for (let column=0; column<gridArray[0].length; column++) {
            leftBorder = gridArray[0][column]['leftBorder'];
            rightBorder = gridArray[0][column]['rightBorder'];
            if ((inputX > leftBorder) && (inputX < rightBorder)) {
                columnOfSelectedCell = column;
            }
        }

        context = self.canvas.getContext("2d")
        context.fillRect(gridArray[rowOfSelectedCell][columnOfSelectedCell]['leftBorder'], 
            gridArray[rowOfSelectedCell][columnOfSelectedCell]['topBorder'], 
            gridArray[rowOfSelectedCell][columnOfSelectedCell]['rightBorder'] - gridArray[rowOfSelectedCell][columnOfSelectedCell]['leftBorder'], 
            gridArray[rowOfSelectedCell][columnOfSelectedCell]['bottomBorder'] - gridArray[rowOfSelectedCell][columnOfSelectedCell]['topBorder']);

        // console.log("X:", inputX, "\nY: ", inputY); 
        // console.log("Top Border: ", gridArray[rowOfSelectedCell][columnOfSelectedCell]['topBorder']);
        // console.log("Bottom Border: ", gridArray[rowOfSelectedCell][columnOfSelectedCell]['bottomBorder']);
        // console.log("Left Border: ", gridArray[rowOfSelectedCell][columnOfSelectedCell]['leftBorder']);
        // console.log("Right Border: ", gridArray[rowOfSelectedCell][columnOfSelectedCell]['rightBorder']);
        // console.log("Cell row: ", rowOfSelectedCell, "\nCell column: ", columnOfSelectedCell)


    }

}


function createStraightPipe(angle, color) {
    this.width = 300;
    this.height = 100;
    this.x = 100
    this.y = 100
    context = myGameArea.context;
    context.fillStyle = "red";
    context.fillRect(this.x, this.y, this.width, this.height)
}

</script>

<p>We have created a game area! (or at least an empty canvas)</p>

</body>
</html>

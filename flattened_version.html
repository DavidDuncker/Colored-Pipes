<!DOCTYPE html>
<html>
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <style>
    canvas {
        border: 1px solid #d3d3d3;
        background-color: #f1f1f1;
    }
    </style>

</head>
<body onload="window.initializeCanvas()">
    <script type="module">
class Pipe {
    exists = false;
    side1 = null;
    side2 = null;
    color = "green"
}

class SideBorder {
    location = 0;
    associatedPipe = null;
}

class PipeDisplayInsideCell {
    pipe1 = new Pipe;
    pipe2 = new Pipe;
    color = false;

    leftBorder = new SideBorder;
    rightBorder = new SideBorder;
    topBorder = new SideBorder;
    bottomBorder = new SideBorder;
    borders = { "left": this.leftBorder, 
        "right": this.rightBorder, 
        "top": this.topBorder, 
        "bottom": this.bottomBorder }

    canvas = null;
    context = null;
    keyPointsForDrawingPipes = {};
    parentCell = null;

    constructor(cell, pipe1Entrance, pipe1Exit, pipe2Entrance, pipe2Exit) {

        this.leftBorder.location = cell.leftBorder;
        this.rightBorder.location = cell.rightBorder;
        this.topBorder.location = cell.topBorder;
        this.bottomBorder.location = cell.bottomBorder;
        this.canvas = cell.canvas;
        this.context = cell.canvas.getContext("2d");
        this.parentCell = cell;

        this.getKeyPointsForDrawingPipes();
    };

    getKeyPointsForDrawingPipes() {
        var pipeWidthAsPercentage = 0.3;
        var pipeBorderWidthAsPercentage = 0.1;
        var pipeLengthBeforeCurvingOverToPerpendicularSide = 0.3;

        var cellWidth = this.rightBorder.location - this.leftBorder.location;
        var cellHeight = this.bottomBorder.location - this.topBorder.location;

        //The points needed for drawing a pipe from the top of the cell
        {
            this.keyPointsForDrawingPipes['top'] = {};
            this.keyPointsForDrawingPipes['top']['center'] = {
                'x': (this.leftBorder.location + this.rightBorder.location)/2, 
                'y': this.topBorder.location
            };
            this.keyPointsForDrawingPipes['top']['counterclockwise'] = {};
            this.keyPointsForDrawingPipes['top']['counterclockwise']['outer'] = {};
            this.keyPointsForDrawingPipes['top']['counterclockwise']['inner'] = {};

            this.keyPointsForDrawingPipes['top']['counterclockwise']['outer']['pipe'] = {
                'x': this.keyPointsForDrawingPipes['top']['center']['x'] - cellWidth * pipeWidthAsPercentage / 2,
                'y': this.topBorder.location
            }
            this.keyPointsForDrawingPipes['top']['counterclockwise']['outer']['border'] = {
                'x': this.keyPointsForDrawingPipes['top']['counterclockwise']['outer']['pipe']['x'] - cellWidth * pipeBorderWidthAsPercentage,
                'y': this.topBorder.location
            }
            this.keyPointsForDrawingPipes['top']['clockwise'] = {};
            this.keyPointsForDrawingPipes['top']['clockwise']['outer'] = {};
            this.keyPointsForDrawingPipes['top']['clockwise']['inner'] = {};
            this.keyPointsForDrawingPipes['top']['clockwise']['outer']['pipe'] = {
                'x': this.keyPointsForDrawingPipes['top']['center']['x'] + cellWidth * pipeWidthAsPercentage / 2,
                'y': this.topBorder.location
            }
            this.keyPointsForDrawingPipes['top']['clockwise']['outer']['border'] = {
                'x': this.keyPointsForDrawingPipes['top']['clockwise']['outer']['pipe']['x'] + cellWidth * pipeBorderWidthAsPercentage,
                'y': this.topBorder.location
            }
            this.keyPointsForDrawingPipes['top']['counterclockwise']['inner']['pipe'] = {
                'x': this.keyPointsForDrawingPipes['top']['center']['x'] - cellWidth * pipeWidthAsPercentage / 2,
                'y': this.topBorder.location + cellHeight * pipeLengthBeforeCurvingOverToPerpendicularSide
            }
            this.keyPointsForDrawingPipes['top']['counterclockwise']['inner']['border'] = {
                'x': this.keyPointsForDrawingPipes['top']['counterclockwise']['outer']['border']['x'],
                'y': this.topBorder.location + cellHeight * pipeLengthBeforeCurvingOverToPerpendicularSide
            }
            this.keyPointsForDrawingPipes['top']['clockwise']['inner']['pipe'] = {
                'x': this.keyPointsForDrawingPipes['top']['center']['x'] + cellWidth * pipeWidthAsPercentage / 2,
                'y': this.topBorder.location + cellHeight * pipeLengthBeforeCurvingOverToPerpendicularSide
            }
            this.keyPointsForDrawingPipes['top']['clockwise']['inner']['border'] = {
                'x': this.keyPointsForDrawingPipes['top']['clockwise']['outer']['border']['x'],
                'y': this.topBorder.location + cellHeight * pipeLengthBeforeCurvingOverToPerpendicularSide
            }
        }
        
        //The points needed for drawing a pipe from the bottom of the cell
        {
            this.keyPointsForDrawingPipes['bottom'] = {};
            this.keyPointsForDrawingPipes['bottom']['center'] = {
                'x': (this.leftBorder.location + this.rightBorder.location)/2, 
                'y': this.bottomBorder.location
            };
            this.keyPointsForDrawingPipes['bottom']['clockwise'] = {};
            this.keyPointsForDrawingPipes['bottom']['clockwise']['outer'] = {};
            this.keyPointsForDrawingPipes['bottom']['clockwise']['inner'] = {};
            this.keyPointsForDrawingPipes['bottom']['clockwise']['outer']['pipe'] = {
                'x': this.keyPointsForDrawingPipes['bottom']['center']['x'] - cellWidth * pipeWidthAsPercentage / 2,
                'y': this.bottomBorder.location
            }
            this.keyPointsForDrawingPipes['bottom']['clockwise']['outer']['border'] = {
                'x': this.keyPointsForDrawingPipes['bottom']['clockwise']['outer']['pipe']['x'] - cellWidth * pipeBorderWidthAsPercentage,
                'y': this.bottomBorder.location
            }
            this.keyPointsForDrawingPipes['bottom']['counterclockwise'] = {};
            this.keyPointsForDrawingPipes['bottom']['counterclockwise'] = {};
            this.keyPointsForDrawingPipes['bottom']['counterclockwise']['outer'] = {};
            this.keyPointsForDrawingPipes['bottom']['counterclockwise']['inner'] = {};
            this.keyPointsForDrawingPipes['bottom']['counterclockwise']['outer']['pipe'] = {
                'x': this.keyPointsForDrawingPipes['bottom']['center']['x'] + cellWidth * pipeWidthAsPercentage / 2,
                'y': this.bottomBorder.location
            }
            this.keyPointsForDrawingPipes['bottom']['counterclockwise']['outer']['border'] = {
                'x': this.keyPointsForDrawingPipes['bottom']['counterclockwise']['outer']['pipe']['x'] + cellWidth * pipeBorderWidthAsPercentage,
                'y': this.bottomBorder.location
            }
            this.keyPointsForDrawingPipes['bottom']['clockwise']['inner']['pipe'] = {
                'x': this.keyPointsForDrawingPipes['bottom']['clockwise']['outer']['pipe']['x'],
                'y': this.bottomBorder.location - cellHeight * pipeLengthBeforeCurvingOverToPerpendicularSide
            }
            this.keyPointsForDrawingPipes['bottom']['clockwise']['inner']['border'] = {
                'x': this.keyPointsForDrawingPipes['bottom']['clockwise']['outer']['border']['x'],
                'y': this.bottomBorder.location - cellHeight * pipeLengthBeforeCurvingOverToPerpendicularSide
            }
            this.keyPointsForDrawingPipes['bottom']['counterclockwise']['inner']['pipe'] = {
                'x': this.keyPointsForDrawingPipes['bottom']['counterclockwise']['outer']['pipe']['x'],
                'y': this.bottomBorder.location - cellHeight * pipeLengthBeforeCurvingOverToPerpendicularSide
            }
            this.keyPointsForDrawingPipes['bottom']['counterclockwise']['inner']['border'] = {
                'x': this.keyPointsForDrawingPipes['bottom']['counterclockwise']['outer']['border']['x'],
                'y': this.bottomBorder.location - cellHeight * pipeLengthBeforeCurvingOverToPerpendicularSide
            }
        }
        
        //The points needed for drawing a pipe from the left of the cell
        {
            this.keyPointsForDrawingPipes['left'] = {};
            this.keyPointsForDrawingPipes['left']['center'] = {
                'x': this.leftBorder.location,
                'y': (this.topBorder.location + this.bottomBorder.location)/2, 
            };
            this.keyPointsForDrawingPipes['left']['clockwise'] = {};
            this.keyPointsForDrawingPipes['left']['clockwise']['outer'] = {};
            this.keyPointsForDrawingPipes['left']['clockwise']['inner'] = {};
            this.keyPointsForDrawingPipes['left']['clockwise']['outer']['pipe'] = {
                'x': this.leftBorder.location,
                'y': this.keyPointsForDrawingPipes['left']['center']['y'] - cellHeight * pipeWidthAsPercentage / 2,
            }
            this.keyPointsForDrawingPipes['left']['clockwise']['outer']['border'] = {
                'x': this.leftBorder.location,
                'y': this.keyPointsForDrawingPipes['left']['clockwise']['outer']['pipe']['y'] - cellHeight * pipeBorderWidthAsPercentage,
            }
            this.keyPointsForDrawingPipes['left']['counterclockwise'] = {};
            this.keyPointsForDrawingPipes['left']['counterclockwise']['outer'] = {};
            this.keyPointsForDrawingPipes['left']['counterclockwise']['inner'] = {};
            this.keyPointsForDrawingPipes['left']['counterclockwise']['outer']['pipe'] = {
                'x': this.leftBorder.location,
                'y': this.keyPointsForDrawingPipes['left']['center']['y'] + cellHeight * pipeWidthAsPercentage / 2,
            }
            this.keyPointsForDrawingPipes['left']['counterclockwise']['outer']['border'] = {
                'x': this.leftBorder.location,
                'y': this.keyPointsForDrawingPipes['left']['counterclockwise']['outer']['pipe']['y'] + cellHeight * pipeBorderWidthAsPercentage,
            }
            this.keyPointsForDrawingPipes['left']['clockwise']['inner']['pipe'] = {
                'x': this.leftBorder.location + cellWidth * pipeLengthBeforeCurvingOverToPerpendicularSide,
                'y': this.keyPointsForDrawingPipes['left']['clockwise']['outer']['pipe']['y'],
            }
            this.keyPointsForDrawingPipes['left']['clockwise']['inner']['border'] = {
                'x': this.leftBorder.location + cellWidth * pipeLengthBeforeCurvingOverToPerpendicularSide,
                'y': this.keyPointsForDrawingPipes['left']['clockwise']['outer']['border']['y'],
            }
            this.keyPointsForDrawingPipes['left']['counterclockwise']['inner']['pipe'] = {
                'x': this.leftBorder.location + cellWidth * pipeLengthBeforeCurvingOverToPerpendicularSide,
                'y': this.keyPointsForDrawingPipes['left']['counterclockwise']['outer']['pipe']['y'],
            }
            this.keyPointsForDrawingPipes['left']['counterclockwise']['inner']['border'] = {
                'x': this.leftBorder.location + cellWidth * pipeLengthBeforeCurvingOverToPerpendicularSide,
                'y': this.keyPointsForDrawingPipes['left']['counterclockwise']['outer']['border']['y'],
            }
        }
        
        //The points needed for drawing a pipe from the right of the cell
        {
            this.keyPointsForDrawingPipes['right'] = {};
            this.keyPointsForDrawingPipes['right']['center'] = {
                'x': this.rightBorder.location,
                'y': (this.topBorder.location + this.bottomBorder.location)/2, 
            };
            this.keyPointsForDrawingPipes['right']['counterclockwise'] = {};
            this.keyPointsForDrawingPipes['right']['counterclockwise']['outer'] = {};
            this.keyPointsForDrawingPipes['right']['counterclockwise']['inner'] = {};

            this.keyPointsForDrawingPipes['right']['counterclockwise']['outer']['pipe'] = {
                'x': this.rightBorder.location,
                'y': this.keyPointsForDrawingPipes['right']['center']['y'] - cellHeight * pipeWidthAsPercentage / 2,
            }
            this.keyPointsForDrawingPipes['right']['counterclockwise']['outer']['border'] = {
                'x': this.rightBorder.location,
                'y': this.keyPointsForDrawingPipes['right']['counterclockwise']['outer']['pipe']['y'] - cellHeight * pipeBorderWidthAsPercentage,
            }
            this.keyPointsForDrawingPipes['right']['clockwise'] = {};
            this.keyPointsForDrawingPipes['right']['clockwise']['outer'] = {};
            this.keyPointsForDrawingPipes['right']['clockwise']['inner'] = {};
            this.keyPointsForDrawingPipes['right']['clockwise']['outer']['pipe'] = {
                'x': this.rightBorder.location,
                'y': this.keyPointsForDrawingPipes['right']['center']['y'] + cellHeight * pipeWidthAsPercentage / 2,
            }
            this.keyPointsForDrawingPipes['right']['clockwise']['outer']['border'] = {
                'x': this.rightBorder.location,
                'y': this.keyPointsForDrawingPipes['right']['clockwise']['outer']['pipe']['y'] + cellHeight * pipeBorderWidthAsPercentage,
            }
            this.keyPointsForDrawingPipes['right']['counterclockwise']['inner']['pipe'] = {
                'x': this.rightBorder.location - cellWidth * pipeLengthBeforeCurvingOverToPerpendicularSide,
                'y': this.keyPointsForDrawingPipes['right']['center']['y'] - cellHeight * pipeWidthAsPercentage / 2,
            }
            this.keyPointsForDrawingPipes['right']['counterclockwise']['inner']['border'] = {
                'x': this.rightBorder.location - cellWidth * pipeLengthBeforeCurvingOverToPerpendicularSide,
                'y': this.keyPointsForDrawingPipes['right']['counterclockwise']['outer']['border']['y'],
            }
            this.keyPointsForDrawingPipes['right']['clockwise']['inner']['pipe'] = {
                'x': this.rightBorder.location - cellWidth * pipeLengthBeforeCurvingOverToPerpendicularSide,
                'y': this.keyPointsForDrawingPipes['right']['clockwise']['outer']['pipe']['y'],
            }
            this.keyPointsForDrawingPipes['right']['clockwise']['inner']['border'] = {
                'x': this.rightBorder.location - cellWidth * pipeLengthBeforeCurvingOverToPerpendicularSide,
                'y': this.keyPointsForDrawingPipes['right']['clockwise']['outer']['border']['y'],
            }
        }
        
    }

    drawPipe(side1, side2, color) {
        var whichPipe = null;

        // //Determine if the sides of the cell are already occupied
        // if (this.borders[side1].associatedPipe != null | this.borders[side2].associatedPipe != null) {
        //     console.log("Pipe already exist in border")
        // }

        //Determine if we should label this pipe "Pipe 1" or "Pipe 2", and update the Pipe Display class
        if (this.pipe1.exists == false) {
            this.pipe1.exists = true;
            this.pipe1.side1 = side1;
            this.pipe1.side2 = side2;
            this.whichPipe = "pipe1";
        }

        else if (this.pipe2.exists == true 
                && this.pipe2.exists == false) {
            this.pipe2.exists = true;
            this.pipe2.side1 = side1;
            this.pipe2.side2 = side2;
            this.whichPipe = "pipe2";
        }

        else  if (this.pipe2.exists == true 
            && this.pipe2.exists == true) {
            console.log("Too many pipes!")
        }

        this.drawPipeEdge(side1, color);
        this.drawPipeEdge(side2, color);
        this.drawPipeCenter(side1, side2, color)

        return this.whichPipe

    }

    reDrawCell() {
        this.drawSolidColor(this.parentCell.bgcolor, false)
        if (this.pipe1.exists == true) {
            this.drawPipe(
                this.pipe1.side1,
                this.pipe1.side2,
                this.pipe1.color
            )
    
        }
        if (this.pipe2.exists == true) {
            this.drawPipe(
                this.pipe2.side1,
                this.pipe2.side2,
                this.pipe2.color
            )
    
        }

        if (this.color) {
            this.drawSolidColor(this.color, true)
        }

    }

    drawPipeEdge(direction, color) {
        //draw the borders of the pipe
        this.context.fillStyle = "black";
        ["clockwise", "counterclockwise"].forEach( (rotationalDirection, index) => {
            var x=0;
            var y=0;
            this.context.beginPath();

            x = this.keyPointsForDrawingPipes[direction][rotationalDirection]["inner"]["pipe"]['x'];
            y = this.keyPointsForDrawingPipes[direction][rotationalDirection]["inner"]["pipe"]['y'];
            this.context.moveTo(x, y);

            x = this.keyPointsForDrawingPipes[direction][rotationalDirection]["outer"]["pipe"]['x'];
            y = this.keyPointsForDrawingPipes[direction][rotationalDirection]["outer"]["pipe"]['y'];
            this.context.lineTo(x, y);

            x = this.keyPointsForDrawingPipes[direction][rotationalDirection]["outer"]["border"]['x'];
            y = this.keyPointsForDrawingPipes[direction][rotationalDirection]["outer"]["border"]['y'];
            this.context.lineTo(x, y);

            x = this.keyPointsForDrawingPipes[direction][rotationalDirection]["inner"]["border"]['x'];
            y = this.keyPointsForDrawingPipes[direction][rotationalDirection]["inner"]["border"]['y'];
            this.context.lineTo(x, y);

            x = this.keyPointsForDrawingPipes[direction][rotationalDirection]["inner"]["pipe"]['x'];
            y = this.keyPointsForDrawingPipes[direction][rotationalDirection]["inner"]["pipe"]['y'];
            this.context.lineTo(x, y);

            this.context.fill();

        }
        )

        //draw the interior of the pipe
        this.context.fillStyle = color;
        var x=0;
        var y=0;
        this.context.beginPath();

        x = this.keyPointsForDrawingPipes[direction]["clockwise"]["inner"]["pipe"]['x'];
        y = this.keyPointsForDrawingPipes[direction]["clockwise"]["inner"]["pipe"]['y'];
        this.context.moveTo(x, y);

        x = this.keyPointsForDrawingPipes[direction]["clockwise"]["outer"]["pipe"]['x'];
        y = this.keyPointsForDrawingPipes[direction]["clockwise"]["outer"]["pipe"]['y'];
        this.context.lineTo(x, y);

        x = this.keyPointsForDrawingPipes[direction]["counterclockwise"]["outer"]["pipe"]['x'];
        y = this.keyPointsForDrawingPipes[direction]["counterclockwise"]["outer"]["pipe"]['y'];
        this.context.lineTo(x, y);

        x = this.keyPointsForDrawingPipes[direction]["counterclockwise"]["inner"]["pipe"]['x'];
        y = this.keyPointsForDrawingPipes[direction]["counterclockwise"]["inner"]["pipe"]['y'];
        this.context.lineTo(x, y);

        x = this.keyPointsForDrawingPipes[direction]["clockwise"]["inner"]["pipe"]['x'];
        y = this.keyPointsForDrawingPipes[direction]["clockwise"]["inner"]["pipe"]['y'];
        this.context.lineTo(x, y);

        this.context.fill();

    }

    drawPipeCenter(direction1, direction2, color) {
        //draw the borders of the pipe
        this.context.fillStyle = "black";
        var rotationalDirections = ["clockwise", "counterclockwise"];
        rotationalDirections.forEach( (rotationalDirection, i) => {
            var x=0;
            var y=0;
            this.context.beginPath();

            x = this.keyPointsForDrawingPipes[direction1][rotationalDirections[i]]["inner"]["pipe"]['x'];
            y = this.keyPointsForDrawingPipes[direction1][rotationalDirections[i]]["inner"]["pipe"]['y'];
            this.context.moveTo(x, y);
        
            x = this.keyPointsForDrawingPipes[direction1][rotationalDirections[i]]["inner"]["border"]['x'];
            y = this.keyPointsForDrawingPipes[direction1][rotationalDirections[i]]["inner"]["border"]['y'];
            this.context.lineTo(x, y);
        
            x = this.keyPointsForDrawingPipes[direction2][rotationalDirections[(i+1)%2]]["inner"]["border"]['x'];
            y = this.keyPointsForDrawingPipes[direction2][rotationalDirections[(i+1)%2]]["inner"]["border"]['y'];
            this.context.lineTo(x, y);
        
            x = this.keyPointsForDrawingPipes[direction2][rotationalDirections[(i+1)%2]]["inner"]["pipe"]['x'];
            y = this.keyPointsForDrawingPipes[direction2][rotationalDirections[(i+1)%2]]["inner"]["pipe"]['y'];
            this.context.lineTo(x, y);

            x = this.keyPointsForDrawingPipes[direction1][rotationalDirections[i]]["inner"]["pipe"]['x'];
            y = this.keyPointsForDrawingPipes[direction1][rotationalDirections[i]]["inner"]["pipe"]['y'];
            this.context.lineTo(x, y);

                
            this.context.fill();
        
        }
        )

        //Draw the pipe interior
        this.context.fillStyle = color;
        var x=0;
        var y=0;
        this.context.beginPath();

        x = this.keyPointsForDrawingPipes[direction1]["clockwise"]["inner"]["pipe"]['x'];
        y = this.keyPointsForDrawingPipes[direction1]["clockwise"]["inner"]["pipe"]['y'];
        this.context.moveTo(x, y);
        
        x = this.keyPointsForDrawingPipes[direction1]["counterclockwise"]["inner"]["pipe"]['x'];
        y = this.keyPointsForDrawingPipes[direction1]["counterclockwise"]["inner"]["pipe"]['y'];
        this.context.lineTo(x, y);
        
        x = this.keyPointsForDrawingPipes[direction2]["clockwise"]["inner"]["pipe"]['x'];
        y = this.keyPointsForDrawingPipes[direction2]["clockwise"]["inner"]["pipe"]['y'];
        this.context.lineTo(x, y);
        
        x = this.keyPointsForDrawingPipes[direction2]["counterclockwise"]["inner"]["pipe"]['x'];
        y = this.keyPointsForDrawingPipes[direction2]["counterclockwise"]["inner"]["pipe"]['y'];
        this.context.lineTo(x, y);

        x = this.keyPointsForDrawingPipes[direction1]["clockwise"]["inner"]["pipe"]['x'];
        y = this.keyPointsForDrawingPipes[direction1]["clockwise"]["inner"]["pipe"]['y'];
        this.context.lineTo(x, y);

                
        this.context.fill();        
        

    }

    drawSolidColor(color, newCellSpecificColor=false) {
        if (newCellSpecificColor==true) {
            this.color = color;
       }
        this.context.fillStyle = color;
        this.context.fillRect(this.leftBorder.location-1, this.topBorder.location, 
            this.rightBorder.location - this.leftBorder.location + 1, 
            this.bottomBorder.location - this.topBorder.location + 1)
    }

    drawBorder(color, thickness=3) {
        this.context.fillStyle = color;

        //Draw thin rectangle on left side
        this.context.fillRect(
            this.leftBorder.location,
            this.topBorder.location,
            thickness,
            this.bottomBorder.location - this.topBorder.location)

        //Draw thin rectangle on top side
        this.context.fillRect(
            this.leftBorder.location + thickness,
            this.topBorder.location,
            this.rightBorder.location - this.leftBorder.location - 2*thickness,
            thickness)
        
        //Draw thin rectangle on right side
        this.context.fillRect(
            this.rightBorder.location - thickness,
            this.topBorder.location,
            thickness,
            this.bottomBorder.location - this.topBorder.location)
        
        //Draw thin rectangle on bottom side
        this.context.fillRect(
            this.leftBorder.location + thickness,
            this.bottomBorder.location - thickness,
            this.rightBorder.location - this.leftBorder.location - 2*thickness,
            thickness)

    }

}

class Cell {
    leftBorder = 0;
    rightBorder = 0;
    topBorder = 0;
    bottomBorder = 0;
    pipeDisplay = null;
    canvas = null;
    isSelected = false;
    bgcolor = "#f1f1f1";
    row = null;
    column = null;
    
    constructor(canvas, rowNumber, columnNumber, rowSize, columnSize, bgcolor, row, column) {
        this.canvas = canvas;
        this.topBorder = rowNumber * rowSize;
        this.bottomBorder = (rowNumber + 1) * rowSize;
        this.leftBorder = columnNumber * columnSize;
        this.rightBorder = (columnNumber + 1) * columnSize;
        this.pipeDisplay = new PipeDisplayInsideCell(this, null, null, null, null);
        this.bgcolor = "#f1f1f1";
        this.row = row;
        this.column = column;
    }

    drawPipe(direction1, direction2, color) {
        this.pipeDisplay.drawPipe(direction1, direction2, color);
    }

    makeSelected() {
        this.isSelected = true;
        this.pipeDisplay.drawSolidColor("black")
    }

    makeUnselected() {
        this.isSelected = false;
        this.pipeDisplay.drawSolidColor("white")
    }


}

class canvasInnerGrid {
    numberOfRows = 1;
    numberOfColumns = 1;
    canvas = null;
    gridArray = [];
    selectedCell = null;
    hoveredCell = [0, 0];
    hoveredCellChanged = () => {};
    bgcolor = "#f1f1f1";
    pipeDraggingMode = false;
    canvasInputMethod = 'color';
    pipePath = null;


    

    getCells() {
        var rowSize = this.canvas.height/this.numberOfRows;
        var columnSize = this.canvas.width/this.numberOfColumns;
        var numberOfRows = this.numberOfRows;
        var numberOfColumns = this.numberOfColumns;
        var gridArray = []
        for (let i=0; i<numberOfRows; i++) {
            gridArray.push([]);
            for(let j=0; j<numberOfColumns; j++) {
                var cell = new Cell(this.canvas, i, j, rowSize, columnSize, this.bgcolor, i, j);
                gridArray[i].push(cell);
            }
        }

        return gridArray
    }

    constructor(number_of_rows, number_of_columns, canvas) {
        this.numberOfRows = number_of_rows;
        this.numberOfColumns = number_of_columns;
        this.canvas = canvas;
        this.gridArray = this.getCells();
    }


    createBorders(borderwidth=5, fillstyle="black") {
        this.canvas.fillStyle = fillstyle;
        var canvas = this.canvas
        var context = this.canvas.getContext("2d")
        var gridArray = this.gridArray

        for (let row=0;row<gridArray.length;row++) {
            context.fillRect(0, gridArray[row][0]['topBorder'] - borderwidth, canvas.width, borderwidth);
            // context.fillRect(0, gridArray[row][0]['bottomBorder'] - borderwidth/2, canvas.width, borderwidth);

        }
        for (let column=0;column<gridArray[0].length;column++) {
            context.fillRect(gridArray[0][column]['leftBorder'], 0, borderwidth, canvas.height);
            // context.fillRect(gridArray[0][column]['rightBorder'] - borderwidth/2, 0, borderwidth, canvas.height);

        }

    }

    getCellFromPoint(inputX, inputY) {
        var gridArray = this.gridArray;

        //Find which row of cells the mouse is in
        var rowOfCell = -1;
        for (let row=0; row<gridArray.length; row++) {
            var topBorder = gridArray[row][0]['topBorder'];
            var bottomBorder = gridArray[row][0]['bottomBorder'];
            if ((inputY >= topBorder) && (inputY <= bottomBorder)) {
                rowOfCell = row;
            }
        }

        //Find which column of cells the mouse is in
        var columnOfCell = -1;
        for (let column=0; column<gridArray[0].length; column++) {
            var leftBorder = gridArray[0][column]['leftBorder'];
            var rightBorder = gridArray[0][column]['rightBorder'];
            if ((inputX >= leftBorder) && (inputX <= rightBorder)) {
                columnOfCell = column;
            }
        }
    
        //Do something with every single cell
        // for (let row=0; row<gridArray.length; row++) {
        //     for (let column=0; column<gridArray[0].length; column++) {

        //     }
        // }

        //Do something if the mouse hovers over the margin
        if (rowOfCell == -1 | columnOfCell == -1) {
            [rowOfCell, columnOfCell] = this.hoveredCell
        }

        //Do something if a new cell is being hovered over
        if (rowOfCell != this.hoveredCell[0] | columnOfCell != this.hoveredCell[1]) {
            this.unhoveredCellHandler(this.hoveredCell[0], this.hoveredCell[1]);
            this.hoveredCell = [rowOfCell, columnOfCell];
            this.hoveredCellHandler(rowOfCell, columnOfCell);
        }


        //Do something if a new cell is being hovered over
        if (rowOfCell != this.hoveredCell[0] | columnOfCell != this.hoveredCell[1]) {
            this.unhoveredCellHandler(this.hoveredCell[0], this.hoveredCell[1]);
            this.hoveredCell = [rowOfCell, columnOfCell];
            this.hoveredCellHandler(rowOfCell, columnOfCell);
        }

        
    }

    hoveredCellHandler(rowOfNewHoveredCell, columnOfNewHoveredCell) {
        this.gridArray[rowOfNewHoveredCell][columnOfNewHoveredCell].pipeDisplay.drawBorder("black", 3)
        if (this.canvasInputMethod == 'pipe' && this.pipeDraggingMode == true) {
            this.pipePath.addCell(rowOfNewHoveredCell, columnOfNewHoveredCell)
        }
        else if (this.canvasInputMethod == 'pipe' && this.pipeDraggingMode == false && this.pipePath != null) {
            this.pipePath.declareEndCell(rowOfNewHoveredCell, columnOfNewHoveredCell)
        }

    }
    
    unhoveredCellHandler(rowOfUnhoveredCell, columnOfUnhoveredCell) {
        this.gridArray[rowOfUnhoveredCell][columnOfUnhoveredCell].pipeDisplay.reDrawCell();
    }

};

class cellContainer {
    cellRow = 0;
    cellColumn = 0;
    cell = null;
    previousCellDirection = null;
    nextCellDirection = null;
    chosenPipe = null;

    constructor(cellRow, cellColumn, cell) {
        this.cellRow = cellRow;
        this.cellColumn = cellColumn;
        this.cell = cell;
    }

}

class pipePath {
    grid = null;
    gridArray = null;

    startCell = null;
    listOfCells = [];
    endCell = null;

    constructor(grid) {
        this.grid = grid;
        this.gridArray = grid.gridArray;
    }

    declareStartCell(cellRow, cellColumn) {
        var cell = this.gridArray[cellRow][cellColumn];
        this.startCell = new cellContainer(cellRow, cellColumn, cell);
    }

    addCell(cellRow, cellColumn) {
        var newCell = this.gridArray[cellRow][cellColumn];
        var newCellCont = new cellContainer(cellRow, cellColumn, newCell);

        if (this.startCell == null) {
            this.declareStartCell(cellRow, cellColumn)
        }
        this.listOfCells.push(newCellCont)
        if (this.listOfCells.length >= 3) {
            this.calculatePipeDirectionsAndDrawPipes(this.listOfCells)
        }

    }

    declareEndCell(cellRow, cellColumn) {
        var cell = this.gridArray[cellRow][cellColumn];
        this.endCell = new cellContainer(cellRow, cellColumn, cell);
        createGradient(this.listOfCells);

    }

    calculatePipeDirectionsAndDrawPipes(listOfCells) {
        var lastCellIndex = listOfCells.length-1;
        var secondToLastCellIndex = listOfCells.length-2;
        var thirdToLastCellIndex = listOfCells.length-3
        var direction1 = this.compareTwoCells(listOfCells, secondToLastCellIndex, thirdToLastCellIndex)
        var direction2 = this.compareTwoCells(listOfCells, secondToLastCellIndex, lastCellIndex)
        var chosenPipe = listOfCells[secondToLastCellIndex].cell.pipeDisplay.drawPipe(direction1, direction2, "green");
        listOfCells[secondToLastCellIndex].chosenPipe = chosenPipe
    }

    compareTwoRows(listOfCells, mainIndex, comparisonIndex) {
        var mainCellRowIndex = listOfCells[mainIndex].cell.row;
        var comparisonCellRowIndex = listOfCells[comparisonIndex].cell.row;

        var comparisonResult = false;
        var differenceInRows = mainCellRowIndex - comparisonCellRowIndex;
        if (differenceInRows == 1) {
            comparisonResult = "top";
        }
        else if (differenceInRows == -1) {
            comparisonResult = "bottom";
        }
        return comparisonResult

    }

    compareTwoColumns(listOfCells, mainIndex, comparisonIndex) {
        var mainCellColumnIndex = listOfCells[mainIndex].cell.column;
        var comparisonCellColumnIndex = listOfCells[comparisonIndex].cell.column;

        var comparisonResult = false;
        var differenceInColumns = mainCellColumnIndex - comparisonCellColumnIndex;
        if (differenceInColumns == 1) {
            comparisonResult = "left";
        }
        else if (differenceInColumns == -1) {
            comparisonResult = "right";
        }
        return comparisonResult
    }

    compareTwoCells(listOfCells, mainIndex, comparisonIndex) {
        var rowResult = this.compareTwoRows(listOfCells, mainIndex, comparisonIndex)
        var columnResult = this.compareTwoColumns(listOfCells, mainIndex, comparisonIndex)
        if (rowResult != false) {
            return rowResult
        }

        if (columnResult != false) {
            return columnResult
        }

        return false

    }


}

function createGradient(listOfCells) {
    if (listOfCells[0].cell.pipeDisplay.color) {
        var firstColor = listOfCells[0].cell.pipeDisplay.color;
    }
    else {
        var firstColor = listOfCells[0].cell.bgcolor;
    }

    if (listOfCells[listOfCells.length-1].cell.pipeDisplay.color) {
        var lastColor = listOfCells[listOfCells.length-1].cell.pipeDisplay.color;
    }
    else {
        var lastColor = listOfCells[listOfCells.length-1].cell.bgcolor;
    }

    var firstRedShade = parseInt(firstColor.substring(1,3), 16);
    var lastRedShade = parseInt(lastColor.substring(1,3), 16);
    var averageChangeInShade = (lastRedShade - firstRedShade)/listOfCells.length
    var listOfRedShades = Array.from({length: listOfCells.length}, (_, i) => parseInt(firstRedShade + i*averageChangeInShade, 10).toString(16))
    for (let i=0;i<listOfRedShades.length; i++) {
        if (listOfRedShades[i].length == 1) {
            listOfRedShades[i] = '0' + listOfRedShades[i];
        }
    }

    var firstGreenShade = parseInt(firstColor.substring(3,5), 16);
    var lastGreenShade = parseInt(lastColor.substring(3,5), 16);
    var averageChangeInShade = (lastGreenShade - firstGreenShade)/listOfCells.length
    var listOfGreenShades = Array.from({length: listOfCells.length}, (_, i) => parseInt(firstGreenShade + i*averageChangeInShade, 10).toString(16))
    for (let i=0;i<listOfGreenShades.length; i++) {
        if (listOfGreenShades[i].length == 1) {
            listOfGreenShades[i] = '0' + listOfGreenShades[i];
        }
    }


    var firstBlueShade = parseInt(firstColor.substring(5,7), 16);
    var lastBlueShade = parseInt(lastColor.substring(5,7), 16);
    var averageChangeInShade = (lastBlueShade - firstBlueShade)/listOfCells.length
    var listOfBlueShades = Array.from({length: listOfCells.length}, (_, i) => parseInt(firstBlueShade + i*averageChangeInShade, 10).toString(16))
    for (let i=0;i<listOfBlueShades.length; i++) {
        if (listOfBlueShades[i].length == 1) {
            listOfBlueShades[i] = '0' + listOfBlueShades[i];
        }
    }


    var listOfNewColors = Array.from({length: listOfCells.length}, (_, i) => "#" + listOfRedShades[i] + listOfGreenShades[i] + listOfBlueShades[i])

    for (let i=1;i<listOfCells.length-1;i++) {
        var chosenPipe = listOfCells[i].chosenPipe
        listOfCells[i].cell.pipeDisplay[chosenPipe].color = listOfNewColors[i];
        listOfCells[i].cell.pipeDisplay.reDrawCell();
    }

}
        window.canvas = {};
        window.canvas.inputColor = "#FFA000";
        window.canvas.inputMethod = "color";
        window.canvas.grid = null;


        function initializeCanvas() {
            canvasArea.open();
            window.canvas.grid = new canvasInnerGrid(7, 15, canvasArea.canvas);

            canvasArea.canvas.addEventListener("mousedown", (e) => {})
            canvasArea.canvas.addEventListener("mousemove", (e) => {
                window.canvas.grid.getCellFromPoint(e.offsetX, e.offsetY)
                if (window.canvas.grid.pipeDraggingMode == true && window.canvas.inputMethod == "pipe") {
                    window.canvas.grid.hoveredCellChanged = () => {}
                }
                else if (window.canvas.grid.pipeDraggingMode == false && window.canvas.inputMethod == "pipe") {
                    window.canvas.grid.hoveredCellChanged = () => {}
                }
            })
            canvasArea.canvas.addEventListener("mouseup", (e) => {})
            canvasArea.canvas.addEventListener("click", (e) => {
                if (window.canvas.inputMethod == "color") {
                    var selected_row = window.canvas.grid.hoveredCell[0];
                    var selected_column = window.canvas.grid.hoveredCell[1];
                    window.canvas.grid.gridArray[selected_row][selected_column].pipeDisplay.drawSolidColor(window.canvas.inputColor, true)
                }

                console.log("window.canvas.inputMethod", window.canvas.inputMethod);
                console.log("window.canvas.grid.pipeDraggingMode", window.canvas.grid.pipeDraggingMode)
                if (window.canvas.inputMethod == "pipe") {
                    window.canvas.grid.pipeDraggingMode = !window.canvas.grid.pipeDraggingMode
                    if (window.canvas.grid.pipeDraggingMode) {
                        window.canvas.grid.pipePath = new pipePath(window.canvas.grid);
                        window.canvas.grid.getCellFromPoint(e.offsetX, e.offsetY);
                        var cellRow = window.canvas.grid.hoveredCell[0];
                        var cellColumn = window.canvas.grid.hoveredCell[1];
                        window.canvas.grid.pipePath.addCell(cellRow, cellColumn)

                    }
                    else {
                        window.canvas.grid.getCellFromPoint(e.offsetX, e.offsetY);
                        var cellRow = window.canvas.grid.hoveredCell[0];
                        var cellColumn = window.canvas.grid.hoveredCell[1];
                        window.canvas.grid.pipePath.declareEndCell(cellRow, cellColumn)

                    }

                }
                console.log("window.canvas.grid.pipeDraggingMode", window.canvas.grid.pipeDraggingMode)

            })

        }

        var canvasArea = {
            canvas : document.createElement("canvas"),
            open : function() {
                this.canvas.width = 480;
                this.canvas.height = 270;
                this.context = this.canvas.getContext("2d");
                document.body.insertBefore(this.canvas, document.body.childNodes[0]);
            }
        }
        

        window.initializeCanvas = initializeCanvas;
    </script>
    <script src="jscolor.js"></script>


    <h1>David Duncker's Color Gradient Pipe Creator</h1>
    <hr>
    
    <form onsubmit="showFormData(this); return false;">
        <h2>Input options</h2>
        1. Pick a color: <button data-jscolor="{valueElement:'#color'}"></button>
        <input id="color" value="FFA000" name="color" type="hidden"><br><br>
    
        2. Choose an action:<br>
        <input type="radio" name="input_method" id="solid_color" value="color">
        <label for="solid_color">Fill the cells of the canvas with the selected color</label><br>
    
        <input type="radio" name="input_method" id="gradient_pipe" value="pipe">
        <label for="gradient_pipe">Connect the colored cells with a draggable pipe that creates a color gradient (Click, Drag, Click)</label><br><br>
    
        3. Click below to update changes:<br>
        <input type="submit" value="Update input for canvas">
    
        <hr>
    
        <h2>Instructions</h2>

        <p>
            <b>Step 1:</b> Pick a color
        </p>
        <p><b>Step 2:</b> Click on "Fill the cells of the canvas with the selected color", under "Choose an action"</p>
        <p><b>Step 3:</b> Press "Update input for canvas"</p>
        <p><b>Step 4:</b> Click on several different parts of the canvas <br>
                to fill the canvas cells with solid colors</p>
    
    
        <p><b>Step 5:</b> Click on "Connect the colored cells with <br>
            a draggable pipe that creates a color gradient"</p>
        <p><b>Step 6:</b> Press "Update input for canvas"</p>
        <p><b>Step 7:</b> Click on a colored cell in the canvas, <br>
            slowly drag the mouse to another colored cell, <br>
            then click on that 2nd colored cell</p><br>
    
        </p>
        
    </form>
    

<pre id="form-data"></pre>

<script>
// Helper function that displays submitted form data
function showFormData(form) {
    window.form = form
    var lines = [];
    window.form = {};

    for (var i = 0; i < form.elements.length; i++) {
        var e = form.elements[i];
        // console.log(e);
        if (e.name && ((e.type == 'radio' && e.checked) || (e.type != 'radio'))) {
            lines.push(e.name + ' = ' + e.value);
            if (e.name == "color") {
                window.canvas.inputColor = e.value
                window.canvas.grid.canvasInputMethod = 'color'

            }
            else if (e.name == "input_method") {
                window.canvas.inputMethod = e.value
                window.canvas.grid.canvasInputMethod = 'pipe'
            }

        }
    }
}
</script></body>
</html>
